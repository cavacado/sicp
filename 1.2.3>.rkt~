#lang sicp

; (count-change 11)
; |
; (cc 11 5)__
; |          \
; (cc 11 4)   (cc -39 5)
; |       \___
; |           \
; (cc 11 3)   (cc -14 4)
; |       \_______________________________________________________
; |                                                               \
; (cc 11 2)                                                      (cc 1 3)
; |       \_________________________                              |     \__
; |                                 \                             |        \
; (cc 11 1)                        (cc 6 2)                      (cc 1 2) (cc -9 2)
; |       \___                      |     \__                     |     \__
; |           \                     |        \                    |        \
; (cc 11 0)   (cc 10 1)            (cc 6 1) (cc 1 2)             (cc 1 1) (cc -4 2)
;         __/ |                 __/ |       |     \__            |     \__
;         /    |                /    |       |        \           |        \
; (cc 10 0)   (cc 9 1)  (cc 6 0)   (cc 5 1) (cc 1 1) (cc -4 2)   (cc 1 0) (cc 0 1)
;         __/ |                 __/ |       |     \__
;         /    |                /    |       |        \
; (cc 9 0)    (cc 8 1)  (cc 5 0)   (cc 4 1) (cc 1 0) (cc 0 1)
;         __/ |                 __/ |
;         /    |                /    |
; (cc 8 0)    (cc 7 1)  (cc 4 0)   (cc 3 1)
;         __/ |                 __/ |
;         /    |                /    |
; (cc 7 0)    (cc 6 1)  (cc 3 0)   (cc 2 1)
;         __/ |                 __/ |
;         /    |                /    |
; (cc 6 0)    (cc 5 1)  (cc 2 0)   (cc 1 1)
;         __/ |                 __/ |
;         /    |                /    |
; (cc 5 0)    (cc 4 1)  (cc 1 0)   (cc 0 1)
;         __/ |
;         /    |
; (cc 4 0)    (cc 3 1)
;         __/ |
;         /    |
; (cc 3 0)    (cc 2 1)
;         __/ |
;         /    |
; (cc 2 0)    (cc 1 1)
;         __/ |
;         /    |
; (cc 1 0)    (cc 0 1)
; might be a little cut off

; ex 1.15

(define (cube x) (* x x x))
(define (p x) (- (* 3 x) (* 4 (cube x))))
(define (sine angle)
  (if (not (> (abs angle) 0.1))
      angle
      (p (sine (/ angle 3.0)))))

; (sine 12.15)
; (p (sine (/ 12.15 3.0)))
; (p (sine 4.05))
; (p (p (sine (/ 4.05 3.0))))
; (p (p (sine 1.349999...)))
; (p (p (p (sine (/ 1.349999... 3.0)))))
; (p (p (p (p (sine (/ .... 3.0))))))
; (p (p (p (p (p (/ ...... 3.0))))))
; procedure p is applied 5 times

; The angle a is divided by 3 each time the procedure p is applied. Expressing this differently, we can say that p is applied once for each complete power of 3 contained within the angle a. Therefore, given a positive argument, we can compute the number of times p is applied as the ceiling of the base 3 logarithm of the argument divided by 0.1, or (ceiling(/ (log (/ 12.15 0.1)) (log 3)))

; If we measure the required space and the number of steps by counting the invocations of p, the order of growth of the process generated by (sine a) is logarithmic. Exactly, the number of steps required are (ceiling(/ (log (/ a 0.1)) (log 3))).

; In other words we have O(log(x)) order of growth.

(define (expt' b n)
  (if (= n 0)
      1
      (* b (expt' b (- n 1)))))

(define (expt'' b n)
  (expt-iter b n 1))

(define (expt-iter b counter product)
  (if (= counter 0)
      product
      (expt-iter b
                 (- counter 1)
                 (* b product))))

(define (fast-expt b n)
  (cond ((= n 0)
          1)
        ((even? n)
         (square (fast-expt b (/ n 2))))
        (else
          (* b (fast-expt b (- n 1))))))

(define (square x) (* x x))
(define (even? n)
  (= (mod n 2) 0))

; (define (even? n)
;   (= (remainder n 2) 0))

(define (expt-log b n)
  (expt-iter-log 1 b n))

(define (expt-iter-log a b counter)
  (cond ((= counter 0) a)
        ((even? counter) (expt-iter-log a (square b) (/ counter 2)))
        (else (expt-iter-log (* a b) b (- counter 1)))))
