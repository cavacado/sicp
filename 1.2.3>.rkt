#lang sicp

; (count-change 11)
; |
; (cc 11 5)__
; |          \
; (cc 11 4)   (cc -39 5)
; |       \___
; |           \
; (cc 11 3)   (cc -14 4)
; |       \_______________________________________________________
; |                                                               \
; (cc 11 2)                                                      (cc 1 3)
; |       \_________________________                              |     \__
; |                                 \                             |        \
; (cc 11 1)                        (cc 6 2)                      (cc 1 2) (cc -9 2)
; |       \___                      |     \__                     |     \__
; |           \                     |        \                    |        \
; (cc 11 0)   (cc 10 1)            (cc 6 1) (cc 1 2)             (cc 1 1) (cc -4 2)
;         __/ |                 __/ |       |     \__            |     \__
;         /    |                /    |       |        \           |        \
; (cc 10 0)   (cc 9 1)  (cc 6 0)   (cc 5 1) (cc 1 1) (cc -4 2)   (cc 1 0) (cc 0 1)
;         __/ |                 __/ |       |     \__
;         /    |                /    |       |        \
; (cc 9 0)    (cc 8 1)  (cc 5 0)   (cc 4 1) (cc 1 0) (cc 0 1)
;         __/ |                 __/ |
;         /    |                /    |
; (cc 8 0)    (cc 7 1)  (cc 4 0)   (cc 3 1)
;         __/ |                 __/ |
;         /    |                /    |
; (cc 7 0)    (cc 6 1)  (cc 3 0)   (cc 2 1)
;         __/ |                 __/ |
;         /    |                /    |
; (cc 6 0)    (cc 5 1)  (cc 2 0)   (cc 1 1)
;         __/ |                 __/ |
;         /    |                /    |
; (cc 5 0)    (cc 4 1)  (cc 1 0)   (cc 0 1)
;         __/ |
;         /    |
; (cc 4 0)    (cc 3 1)
;         __/ |
;         /    |
; (cc 3 0)    (cc 2 1)
;         __/ |
;         /    |
; (cc 2 0)    (cc 1 1)
;         __/ |
;         /    |
; (cc 1 0)    (cc 0 1)
; might be a little cut off

; ex 1.15

(define (cube x) (* x x x))
(define (p x) (- (* 3 x) (* 4 (cube x))))
(define (sine angle)
  (if (not (> (abs angle) 0.1))
      angle
      (p (sine (/ angle 3.0)))))

; (sine 12.15)
; (p (sine (/ 12.15 3.0)))
; (p (sine 4.05))
; (p (p (sine (/ 4.05 3.0))))
; (p (p (sine 1.349999...)))
; (p (p (p (sine (/ 1.349999... 3.0)))))
; (p (p (p (p (sine (/ .... 3.0))))))
; (p (p (p (p (p (/ ...... 3.0))))))
; procedure p is applied 5 times

; The angle a is divided by 3 each time the procedure p is applied. Expressing this differently, we can say that p is applied once for each complete power of 3 contained within the angle a. Therefore, given a positive argument, we can compute the number of times p is applied as the ceiling of the base 3 logarithm of the argument divided by 0.1, or (ceiling(/ (log (/ 12.15 0.1)) (log 3)))

; If we measure the required space and the number of steps by counting the invocations of p, the order of growth of the process generated by (sine a) is logarithmic. Exactly, the number of steps required are (ceiling(/ (log (/ a 0.1)) (log 3))).

; In other words we have O(log(x)) order of growth.

(define (expt-recurse b n)
  (if (= n 0)
      1
      (* b (expt-recurse b (- n 1)))))

(define (expt-iterative b n)
  (expt-iter b n 1))

(define (expt-iter b counter product)
  (if (= counter 0)
      product
      (expt-iter b
                 (- counter 1)
                 (* b product))))

(define (fast-expt b n)
  (cond ((= n 0)
          1)
        ((even? n)
         (square (fast-expt b (/ n 2))))
        (else
          (* b (fast-expt b (- n 1))))))

(define (square x) (* x x))
;(define (even? n)
;  (= (mod n 2) 0))

(define (even? n)
  (= (remainder n 2) 0))

(define (expt-log b n)
  (expt-iter-log 1 b n))

(define (expt-iter-log a b counter)
  (cond ((= counter 0) a)
        ((even? counter) (expt-iter-log a (square b) (/ counter 2)))
        (else (expt-iter-log (* a b) b (- counter 1)))))

;(expt-log 2 5)
;(expt-iter-log 1 2 5)
;(expt-iter-log 2 2 4)
;(expt-iter-log 2 4 2)
;(expt-iter-log 2 16 1)
;(expt-iter-log 32 16 0)
;32

; ex 1.17

(define (cus-mult a b)
  (if (= b 0)
      0
      (+ a (cus-mult a (- b 1)))))

(define (double x)
  (* 2 x))

(define (halve x)
  (/ x 2))

(define (mult-iterative a b)
  (mult-iter 0 a b))

(define (mult-iter x a b)
  (if (= b 0)
      x
      (mult-iter (+ x a)
                 a
                 (- b 1))))

(define (mult-log a b)
  (mult-iter-log 0 a b))

(define (mult-iter-log x a b)
  (cond ((= b 0) x)
        ((even? b) (mult-iter-log (+ x (double a))
                                  a
                                  (- b 2)))
        (else (mult-iter-log (+ x a)
                             a
                             (- b 1)))))

(define (fast-mult a b)
  (cond ((= b 0) 0)
        ((even? b) (double (fast-mult a (halve b))))
        (else (+ a (fast-mult a (- b 1))))))

; ex 1.18

(define (fast-mult-iterative a b)
  (fast-mult-iter 0 a b))

(define (fast-mult-iter x a b)
  (cond ((= b 0) x)
        ((even? b) (fast-mult-iter (double x)
                                   a
                                   (halve b)))
        (else (fast-mult-iter (+ x a)
                              a
                              (- b 1)))))
;; nice!

; ex 1.19

(define (fib n)
  (fib-iter 1 0 0 1 n))

(define (fib-iter a b p q count)
  (cond ((= count 0) b)
        ((even? count) (fib-iter a
                                 b
                                 (+ (square p) (square q))
                                 (+ (* 2 p q) (square q))
                                 (/ count 2)))
        (else (fib-iter (+ (* b q)
                           (* a q)
                           (* a p))
                        (+ (* b p)
                           (* a q))
                        p
                        q
                        (- count 1)))))

(define (gcd x y)
  (if (= y 0)
      x
      (gcd y
           (remainder x y))))

; ex 1.20

;(gcd 206 40)
;
; (if (= 40 0) ...)
;
; (gcd 40 (remainder 206 40))
;
; (if (= (remainder 206 40) 0) ...)
;
; (if (= 6 0) ...)
;
; (gcd (remainder 206 40) (remainder 40 (remainder 206 40)))
;
; (if (= (remainder 40 (remainder 206 40)) 0) ...)
;
; (if (= 4 0) ...)
;
; (gcd (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))
;
; (if (= (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) 0) ...)
;
; (if (= 2 0) ...)
;
; (gcd (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))))
;
; (if (= (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))) 0) ...)
;
; (if (= 0 0) ...)
; (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))

; 18 times for normal-order 14 times for evaluating 4 times for final reduction.

;(gcd 206 40)
;(gcd 40
;     (remainder 206 40))
;(gcd 6
;     (remainder 40 6))
;(gcd 4
;     (remainder 6 4))
;(gcd 2
;     (remainder 4 2))
;(gcd 2 0)
;2
;4 times for applicative-order

(define (smallest-divisor n)
  (find-divisor n 2))

(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n
                            (+ test-divisor 1)))))

(define (divides? a b)
  (= (remainder b a) 0))

(define (prime? n)
  (= n (smallest-divisor n)))

(define (expmod base exp m)
  (cond ((= exp 0) 1)
        ((even? exp) (remainder (square (expmod base (/ exp 2) m))
                                m))
        (else (remainder (* base (expmod base (- exp 1) m))
                         m))))

(define (fermat-test n)
  (define (try-it a)
    (= (expmod a n n) a))
  (try-it (+ 1 (random (- n 1)))))

(define (fast-prime? n times)
  (cond ((= times 0) true)
        ((fermat-test n)
         (fast-prime? n (- times 1)))
        (else false)))

; ex 1.21
; 199, 1999, 7

; ex 1.22

(define (timed-prime-test n)
  (newline)
  (display n)
  (start-prime-test n (runtime)))

(define (start-prime-test n start-time)
  (if (prime? n)
      (report-prime (- (runtime) start-time))))

(define (report-prime elapsed-time)
  (display " *** ")
  (display elapsed-time))

(define (search-for-primes a)
  (search-for-primes-iter a 0))

(define (search-for-primes-iter a count)
  (cond ((= count 3)
         (newline)
         (display " done "))
        (else (helper a count))))

(define (helper a count)
  (timed-prime-test a)
  (cond ((prime? a) (search-for-primes-iter (+ a 2) (+ count 1)))
        (else (search-for-primes-iter (+ a 2) count))))

; yes the timing data increases (sqrt 10) times as order of magnitude increases.
; yes as no. of steps increases, the time needed increases as well
